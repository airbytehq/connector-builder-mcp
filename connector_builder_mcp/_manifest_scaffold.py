"""Manifest scaffold generation tools for Airbyte connectors."""

import logging
from enum import Enum
from typing import Annotated

from pydantic import BaseModel, Field

from connector_builder_mcp._validation_testing import ManifestValidationResult, validate_manifest


logger = logging.getLogger(__name__)


class AuthenticationType(str, Enum):
    """Valid authentication types for connector manifests."""

    NO_AUTH = "NoAuth"
    API_KEY = "ApiKeyAuthenticator"
    BEARER_TOKEN = "BearerAuthenticator"
    BASIC_HTTP = "BasicHttpAuthenticator"
    OAUTH = "OAuthAuthenticator"


class PaginationType(str, Enum):
    """Valid pagination types for connector manifests."""

    NONE = "none"
    PAGE_INCREMENT = "page_increment"
    OFFSET_INCREMENT = "offset_increment"
    CURSOR_PAGINATION = "cursor_pagination"


class ConnectorManifestScaffoldInput(BaseModel):
    """Input model for creating connector manifest scaffold."""

    connector_name: str = Field(
        description="Connector name in kebab-case starting with 'source-'",
        pattern=r"^source-[a-z0-9]+(-[a-z0-9]+)*$",
    )
    api_base_url: str = Field(description="Base URL for the API")
    initial_stream_name: str = Field(description="Name of the initial stream to create")
    initial_stream_path: str = Field(description="API endpoint path for the initial stream")
    authentication_type: AuthenticationType = Field(description="Authentication method (required)")
    primary_key: str = Field(default="TODO", description="Primary key field for the stream")
    http_method: str = Field(default="GET", description="HTTP method for requests")
    record_selector_path: list[str] = Field(
        default_factory=list, description="JSONPath for extracting records"
    )
    pagination_type: PaginationType = Field(
        default=PaginationType.NONE, description="Pagination strategy"
    )


class ConnectorManifestScaffoldResult(BaseModel):
    """Result of creating connector manifest scaffold."""

    success: bool
    manifest_yaml: str | None = None
    validation_result: ManifestValidationResult | None = None
    errors: list[str] = []


def _generate_manifest_yaml_directly(input_data: ConnectorManifestScaffoldInput) -> str:
    """Generate the complete manifest YAML directly with inline comments."""
    header = "# This manifest was generated by the create_connector_manifest_scaffold tool\n# TODO: Review and update before production\n\n"

    auth_yaml = _generate_authenticator_yaml(input_data.authentication_type)

    paginator_yaml = _generate_paginator_yaml(input_data.pagination_type)

    spec_yaml = _generate_connection_spec_yaml(input_data.connector_name, input_data.authentication_type)

    manifest_yaml = f"""{header}version: "4.6.2"
type: DeclarativeSource

definitions:
  authenticator:
{auth_yaml}

check:
  type: CheckStream
  stream_names:
    - {input_data.initial_stream_name}

streams:
  - type: DeclarativeStream
    name: {input_data.initial_stream_name}
    primary_key:
      - {input_data.primary_key}  # TODO: Update with actual primary key field from your API
    retriever:
      type: SimpleRetriever
      requester:
        type: HttpRequester
        url_base: {input_data.api_base_url}
        path: {input_data.initial_stream_path}
        http_method: {input_data.http_method}
        authenticator:
          $ref: "#/definitions/authenticator"
      record_selector:
        type: RecordSelector
        extractor:
          type: DpathExtractor
          field_path: {input_data.record_selector_path}  # TODO: Update after examining API response structure
{paginator_yaml}
      schema_loader:
        type: InlineSchemaLoader
        schema:
          type: object
          properties:
            TODO:  # TODO: Replace with actual schema after examining API response - consider static schema for production performance
              type: string
              description: "Replace with actual schema after examining API response"

spec:
  type: Spec
  documentation_url: https://docs.airbyte.com/integrations/sources/{input_data.connector_name}
  connection_specification:
{spec_yaml}

"""

    manifest_yaml += "\n# TODO: Uncomment and configure incremental sync when ready\n"
    manifest_yaml += "# incremental_sync:\n"
    manifest_yaml += "#   type: DatetimeBasedCursor\n"
    manifest_yaml += "#   cursor_field: updated_at  # TODO: Replace with actual timestamp field\n"
    manifest_yaml += '#   datetime_format: "%Y-%m-%dT%H:%M:%S%z"\n'
    manifest_yaml += "#   start_datetime:\n"
    manifest_yaml += "#     type: MinMaxDatetime\n"
    manifest_yaml += "#     datetime: \"{{ config['start_date'] }}\"\n"
    manifest_yaml += '#     datetime_format: "%Y-%m-%d"\n'
    manifest_yaml += "#   end_datetime:\n"
    manifest_yaml += "#     type: MinMaxDatetime\n"
    manifest_yaml += '#     datetime: "{{ now_utc() }}"\n'
    manifest_yaml += '#     datetime_format: "%Y-%m-%dT%H:%M:%S%z"\n'

    return manifest_yaml


def _generate_authenticator_yaml(auth_type: AuthenticationType) -> str:
    """Generate authenticator YAML configuration with proper indentation."""
    if auth_type == AuthenticationType.NO_AUTH:
        return "    type: NoAuth"
    elif auth_type == AuthenticationType.API_KEY:
        return """    type: ApiKeyAuthenticator
    api_token: "{{ config['api_key'] }}"
    inject_into:
      type: RequestOption
      inject_into: header
      field_name: Authorization"""
    elif auth_type == AuthenticationType.BEARER_TOKEN:
        return """    type: BearerAuthenticator
    api_token: "{{ config['api_token'] }}\""""
    elif auth_type == AuthenticationType.BASIC_HTTP:
        return """    type: BasicHttpAuthenticator
    username: "{{ config['username'] }}"
    password: "{{ config['password'] }}\""""
    elif auth_type == AuthenticationType.OAUTH:
        return """    type: OAuthAuthenticator
    client_id: "{{ config['client_id'] }}"
    client_secret: "{{ config['client_secret'] }}"
    refresh_token: "{{ config['refresh_token'] }}"
    token_refresh_endpoint: "{{ config['token_refresh_endpoint'] }}\""""

    raise ValueError(f"Unsupported authentication type: {auth_type}")


def _generate_paginator_yaml(pagination_type: PaginationType) -> str:
    """Generate paginator YAML configuration with proper indentation."""
    if pagination_type == PaginationType.NONE:
        return "      paginator:\n        type: NoPagination"
    elif pagination_type == PaginationType.PAGE_INCREMENT:
        return """      paginator:
        type: DefaultPaginator
        page_token_option:
          type: RequestOption
          inject_into: request_parameter
          field_name: page
        pagination_strategy:
          type: PageIncrement
          start_from_page: 1"""
    elif pagination_type == PaginationType.OFFSET_INCREMENT:
        return """      paginator:
        type: DefaultPaginator
        page_token_option:
          type: RequestOption
          inject_into: request_parameter
          field_name: offset
        pagination_strategy:
          type: OffsetIncrement
          page_size: 100"""
    elif pagination_type == PaginationType.CURSOR_PAGINATION:
        return """      paginator:
        type: DefaultPaginator
        page_token_option:
          type: RequestOption
          inject_into: request_parameter
          field_name: cursor
        pagination_strategy:
          type: CursorPagination
          cursor_value: "{{ response._metadata.next_cursor }}"
          stop_condition: "{{ not response._metadata.has_more }}\""""

    raise ValueError(f"Unsupported pagination type: {pagination_type}")


def _generate_connection_spec_yaml(connector_name: str, auth_type: AuthenticationType) -> str:
    """Generate connection specification YAML with proper indentation."""
    title = connector_name.replace('-', ' ').title()

    if auth_type == AuthenticationType.NO_AUTH:
        return f"""    $schema: http://json-schema.org/draft-07/schema#
    title: {title} Spec
    type: object
    additionalProperties: true
    properties: {{}}
    required: []"""

    elif auth_type == AuthenticationType.API_KEY:
        return f"""    $schema: http://json-schema.org/draft-07/schema#
    title: {title} Spec
    type: object
    additionalProperties: true
    properties:
      api_key:
        type: string
        airbyte_secret: true
    required:
      - api_key"""

    elif auth_type == AuthenticationType.BEARER_TOKEN:
        return f"""    $schema: http://json-schema.org/draft-07/schema#
    title: {title} Spec
    type: object
    additionalProperties: true
    properties:
      api_token:
        type: string
        airbyte_secret: true
    required:
      - api_token"""

    elif auth_type == AuthenticationType.BASIC_HTTP:
        return f"""    $schema: http://json-schema.org/draft-07/schema#
    title: {title} Spec
    type: object
    additionalProperties: true
    properties:
      username:
        type: string
      password:
        type: string
        airbyte_secret: true
    required:
      - username
      - password"""

    elif auth_type == AuthenticationType.OAUTH:
        return f"""    $schema: http://json-schema.org/draft-07/schema#
    title: {title} Spec
    type: object
    additionalProperties: true
    properties:
      client_id:
        type: string
      client_secret:
        type: string
        airbyte_secret: true
      refresh_token:
        type: string
        airbyte_secret: true
      token_refresh_endpoint:
        type: string
    required:
      - client_id
      - client_secret
      - refresh_token
      - token_refresh_endpoint"""

    raise ValueError(f"Unsupported authentication type: {auth_type}")


def create_connector_manifest_scaffold(
    connector_name: Annotated[
        str, Field(description="Connector name in kebab-case starting with 'source-'")
    ],
    api_base_url: Annotated[str, Field(description="Base URL for the API")],
    initial_stream_name: Annotated[str, Field(description="Name of the initial stream to create")],
    initial_stream_path: Annotated[
        str, Field(description="API endpoint path for the initial stream")
    ],
    authentication_type: Annotated[
        str,
        Field(
            description="Authentication method (NoAuth, ApiKeyAuthenticator, BearerAuthenticator, BasicHttpAuthenticator, OAuthAuthenticator)"
        ),
    ],
    *,
    primary_key: Annotated[str, Field(description="Primary key field for the stream")] = "TODO",
    http_method: Annotated[str, Field(description="HTTP method for requests")] = "GET",
    record_selector_path: Annotated[
        list[str] | None, Field(description="JSONPath for extracting records")
    ] = None,
    pagination_type: Annotated[
        str,
        Field(
            description="Pagination strategy (none, page_increment, offset_increment, cursor_pagination)"
        ),
    ] = "none",
) -> ConnectorManifestScaffoldResult:
    """Create a basic connector manifest scaffold with the specified configuration.

    This tool generates a complete, valid Airbyte connector manifest YAML file
    with proper authentication, pagination, and stream configuration.

    The generated manifest includes TODO placeholders with inline comments for fields
    that need to be filled in later, ensuring the manifest is valid even in its initial state.
    """
    logger.info(f"Creating connector manifest scaffold for {connector_name}")

    try:
        input_data = ConnectorManifestScaffoldInput(
            connector_name=connector_name,
            api_base_url=api_base_url,
            initial_stream_name=initial_stream_name,
            initial_stream_path=initial_stream_path,
            authentication_type=AuthenticationType(authentication_type),
            primary_key=primary_key,
            http_method=http_method.upper(),
            record_selector_path=record_selector_path or [],
            pagination_type=PaginationType(pagination_type),
        )

        manifest_yaml = _generate_manifest_yaml_directly(input_data)

        validation_result = validate_manifest(manifest_yaml)

        return ConnectorManifestScaffoldResult(
            success=validation_result.is_valid,
            manifest_yaml=manifest_yaml,
            validation_result=validation_result,
            errors=validation_result.errors if not validation_result.is_valid else [],
        )

    except ValueError as e:
        return ConnectorManifestScaffoldResult(
            success=False, errors=[f"Input validation error: {str(e)}"]
        )
    except Exception as e:
        logger.error(f"Error creating manifest scaffold: {e}")
        return ConnectorManifestScaffoldResult(
            success=False, errors=[f"Manifest generation error: {str(e)}"]
        )
